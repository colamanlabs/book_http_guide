# HTTP 완벽 가이드

```
2024.04.30
알라딘 ebook 구매
```

## 4장 커넥션 관리


### 4.1 TCP 커넥션

#### 4.1.3 TCP 커넥션 유지하기

```
TCP 커넥션은 4가지 값으로 식별한다.

<발신지 IP 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트>
```

#### 4.2.6 Nagle 알고리즘 과 TCP_NODELAY

```
TCP 가 작은 크기의 데이터를 포함한 많으 수의 패킷을 전송한다면 네트워크 성능은 크게 떨어진다.
네이글 알고리즘은 패킷을 전송하기 전에 많은 양의 TCP 데이터를 한개의 덩어리로 합친다.

네이글 알고리즘은 세그먼트가 최대 크기
(패킷의 최대크기는 LAN 상에서 1500 바이트 정도, 인터넷 상에서는 수백 바이트 정도다)가 되지 않으면 
전송을 하지 않는다.

다만 다른 모든 패킷이 확인 응답을 받았을 경우에는 최대크기보다 작은 패킷의 전송을 허락한다.
다른 패킷들이 아직 전송중이면 데이터는 버퍼에 저장된다.

전송되고 나서 확인응답을 기다리던 패킷이 확인응답을 받았거나,
전송하기 충분할 만큼의 패킷이 쌓였을 때 버퍼에 저장되어 있던 데이터가 전송된다.

네이글 알고리즘은 HTTP 성능 관련해 여러 문제를 발생시킨다.

첫번째로 크기가 작은 HTTP 메세지는 패킷을 채우지 못하기 때문에, 앞으로 생길지 모르는 추가적인 데이터를 기다리며 지연될 것이다.

두번째로 네이글 알고리즘은 확인응답 지연과 함께 쓰일 경우 형편없이 동작한다. 네이들 알고리즘은 확인응답이 도착할 때 까지 데이터 전송을 멈추고 있는 반면, 확인 응답지연 알고리즘은 확인응답을 100~200밀리초 지연시킨다.

HTTP 애플리케이션은 성능 향상을 위해서 HTTP 스텍에 TCP_NODELAY 파라미터값을 설정하여, 네이글 알고리즘을 비활성화 하기도 한다.
이 설정을 했다면, 작은 크기의 패킷이 너무 많이 생기지 않도록 큰 크기의 데이터 덩어리를 만들어야 한다.
```

#### 4.2.7 TIME_WAIT 의 누적과 포트 고갈 

### 4.4 병렬 커넥션

### 4.5 지속 커넥션 
```
서버에 HTTP 요청을 하기 시작한 애플리케이션은 웹 페이지내의 이미지등을 가져오기 위해서 
그 서버에 또 요청하게 될 것이다.
이 속성을 사이트 지역성(site locality)라 부른다.

띠리사. HTTP 1.1 을 지원하는 기기는 처리가 완료된 후에도 TCP 커넥션을 유지하여 
앞으로 있을 HTTP 요청에 재사용 할 수 있다. 
처리가 완료된 후에도 계속 연결 상태로 있는 TCP 커넥션을 지속 커넥션 이라고 한다.
```

#### 4.5.1 지속 커넥션 vs 병렬 커넥션

```
두가지 지속 커넥션 타입이 있는데, HTTP/1.0+ 에는 'keep-alive' 커넥션이 있고,
HTTP/1.1 에는 '지속' 커넥션이 있다.
```

#### 4.5.2 HTTP/1.0+ 의 Keep-Alive 커넥션
```
커넥션을 맺고 끊는데 필요한 작업이 없어서 시간이 단축되었다.
```

#### 4.5.3 Keep-Alive 동작
```
keep-alive 는 사용하지 않기로 결정되어 HTTP/1.1 명세에서 빠졌다.
하지만 아직도 브라우져와 서버간에 keep-alive 핸드셰이크가 널리 사용되고 있기 때문에,
HTTP 애플리케이션은 그것을 처리할 수 있게 개발해야 한다.


HTTP/1.0 keep-alive 커넥션을 구현한 클라이언트는 커넥션을 유지하기 위해 요청에 "Connection:Keep-Alive" 헤더를 포함시킨다.

이 요청을 받은 서버는 그 다음 요청도 이 커넥션을 통해 받고자 한다면,
응답메세지에 같은 헤더를 포함시켜 응답한다. "Connection:Keep-Alive"

응답에 "Connection:Keep-Alive" 헤더가 없으면, 
클라이언트는 서버가 "Connection:Keep-Alive" 를 지원하지 않으며,
응답메세지가 전송되고 나면 서버 커넥션을 끊을 것이라 추정한다.

```

#### 4.5.4 Keep-Alive 옵션
```
Keep-Alive 헤더는 커넥션을 유지하기를 바라는 요청일 뿐이다.
클라이언트나 서버가 keep-alive 요청을 받았다고 해서 무조건 그것을 따를 필요는 없다.

다음예는 서버가 약 5개의 추가 트랜잭션이 처리될 동안 커넥션을 유지하거나,
2분동안 커넥션을 유지하라는 내용의 Keep[-Alive 응답헤더다

Connection:Keep-Alive
Keep-Alive:max=5, timeout=120
```

#### 4.5.5 Keep-Alive 커넥션 제한과 규칙

#### 4.5.6 Keep-ALive 와 멍청한(dumb) 프락시

```
문제는 프락시에서 시작되는데, 
프락시는 Connection 헤더를 이해하지 못해서, 
해당 헤더들을 삭제하지 않고 요청 그대로를 다음 프락시에 전달한다.

오래되고 단순한 수많은 프락시들이 Connection 헤더에 대한 처리 없이 요청을 그대로 전달한다.

- 프락시는 해당 커넥션을 통해 들어오는 새 요청을 모두 무시하면서 커넥션이 끊어지기를 기다린다.
- 프락시는 서버와의 커넥션이 끊어지는 것을 기다리고 있기 때문에, 해당 keep-alive 커넥션을 통해 오는 클라이언트의 두번째 요청은 처리되지 않고 행에 걸린다.
```


#### 4.5.8 Proxy-Connection 살펴보기

```
넷스케이프의 브라우저 및 프락시 개발자들은 차선책을 제시했다.
Proxy-Connection 확장헤더를 프락시에게 전달한다.
영리한 프락시는 Proxy-Connection 헤더를 Connection 헤더로 바꿈으로서 원하던 효과를 얻게 될 것이다.
```


### 4.6 파이프라인 커넥션 


...

# 끝
